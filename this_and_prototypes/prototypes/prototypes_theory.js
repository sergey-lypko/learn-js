// [[Prototype]] - это просто ссылка на другой объект

var ob = {
  a: 1
}

ob.a; // 1

// во время обращения к свойству объекта по-умолчанию выполняется
// оператор [[Get]], который прежде всего проверяет, содержит ли сам 
// объект искомое свойство 
// если свойство не найдено, [[Get]] отправится на поиски свойства 
// в другие объекты по цепочке прототипов

var anotherOb = {
  a: 1
}

var myOb = Object.create(anotherObject);

// фактически, myOb.a на самом деле не существует, однако это значение 
// было найдено в другом объекте, следую по цепочке вверх - anotherOb
myOb.a; // 1

// если свойство не было найдено в ближайшем объекте, такого рода ^ поиски 
// будут продолжаться до того момента, пока цепочка прототипов не закончится
// если свойство так и не было найдено, оператор [[Get]] вернет undefined

// операторы перебора и проверки свойств ищут свойства так же по цепочке прототипов:
var someOb = {
  a: 1
}

var greatOb = Object.create(someOb);

for (var k in greatOb) {
  console.log(k); 
}
// output: a

('a' in greatOb); // true



// Механизм поиска и добавления/изменения свойств в объектах
myObject.foo = 'bar';

// для выполнения такой процедуры ^ выполняются следующие шаги: 
// если объект содержит нормальный дескриптор данных для свойства 
// foo, присвоение представляет собой простую операцию изменения
// значения свойства 

// если конкретный объект не содержит свойства foо,
// выполнитеся поиск вверх, по цепочке
// если свойство не будет найдено нигде, то как и ожидается
// оно будет благополучно записано в объект myObj

// в то же время, если свойство будет найдено где-то по цеопчке, 
// по-сути с этим свойством выше ничего не происходит, однако 
// это же свойство будет записано в текущий объект с приоритетом - 
// это обозначается как shadowing (перекрытие)

// другими словами, при поиске свойства по цепочке прототипов, 
// приоритет выдачи искомого свойства имеет объект, который 
// находится ниже по цепочке



// разберем процесс изменения/установки свойств объектов подробнее
// существует три сценария:

// 1. перекрытие
// свойство с изменяемым (writable: true) дескриптором найдено выше по цепочке прототипов
// в таком случае новое значение свойства благополучно записывается в 
// текущий объект - теперь оно перекрывает любые значение этого же свойства выше по цепочке
var o = {
  a: 1
}

var ob = Objec.create(o);
ob.a = 2;


// 2.
// если свойство, найденное выше по цепочке только для чтения (writable: false)
// в этом случае ни создание нового свойства, не перекрытие недоступны
var ob = {}

Object.defineProperty(ob, 'a', {
  value: 1,
  writable: false
});

var o = Object.create(ob);

// в режиме 'use strcit' будет выброшена ошибка, иначе 
// запись ниже будет просто проигнорирована
o.a = 10;

o.a; // 1
// как видно, перекрытия не произошло
// т.o. вместе со свойствами объекта-прототипа его потенциальные "потомки" "унаследуют"
// так же и дескрипторы этих свойства
// (getOwnPropertyDescriptor такой дескриптор к слову не покажет)


// 3.
// если свойство, найдено выше по цепочке, является сеттером, 
// эта функция-сеттер всегда будет вызваться
// ни функция-сеттер не будет переопределена, ни так же никакого перекрытия
var ob = {
  name: 'Deffault'
}

Object.defineProperty(ob, 'handleName', {
  set: function(value) {
    this.name = value
  }
});

var o = Object.create(ob);
o.handleName = 'nothing';
o.name; // nothing

  
// как видно, перекрытие работает только в 1м случае
// для того, чтобы перекрыть свойстов в случаях 2 и 3, 
// необходимо явно переобпределять дескриптор свойства


