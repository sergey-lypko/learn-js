// ОБЩИЕ ИДЕИ
// представление в виде "чертеж - строение"
// идея заключается в переносе -> КОПИРОВАНИИ всех
// свойств чертежа в строение

// при создании строения на основании чертежа,
// строение физически инициализируется - создается экземпляр,
// если все хорошо, то идеальная копия чертежа
// после чего создаются другие строения - экземпляры
// или другими словами копии

// класс - это чертеж
// для того, чтобы получить объект, с которым можно будет
// взаимодействовать, необходимо выполнить инициализацию
// или непосредственно процесс постройки, если возвращаться
// к аналогии "чертеж - строение"

// в результате получается объект - экземпляр класса, с которым
// можно будет взаимодействовать, вызывать его методы и
// иметь доступ к соответствующим данным
// этот объект - КОПИЯ инструкций, заложенных в классе или чертеже

// вероятнее всего экземпляр класса не будет использовать с целью
// получения и манипуляции свойствами его класса, но обычно имеется
// возможность по крайней мере задать по какому классу
// создавался конкретный экземпляр

// важно рассматривать прямую связь: "класс - экзмпляр",
// чем обратное отношение: "экземпляр - класс"
// класс "создается" в виде процедуры копирования


// ПОЛИМОРФИЗМ
// аспект 1: идея того, что любой метод может ссылаться на другой метод
// (с таким же именем или нет) по иерархии наследоваания

// аспект 2: имя метода может иметь несколько определений на раазных
// уровнях цепочки наследования и эти определния автоматически выбираются
// как подходящие во время соответствующих вызовов

// псевдокод
class Vehicle {
  engines = 1

  ignition() {
    output('turning on my engine')
  }

  drive() {
    ignition()
    output('starting and moving forward')
  }
}

class SpeedBot inherits Vehicle {
  engines = 2

  ignition() {
    output('turning on my engines', engines)
  }

  pilot() {
    // relative polymorphism reference на drive
    // но будет использоваться ignition SpeedBot

    // вот эти полиморфные манипуляции будут зависить от уровня
    // и соответствующего класса & метода в цепочке наследования
    inherited: drive()

    output('Moving throw the water')
  }
}

// NOTE: важно отметить, что при наследовании классов наследование
// происходит именно между классами, но не между объектами, которые
// будут потенциально инициализированы с помщью этих классов
// эта относительная ссылка обычно называется super

// NOTE: классовое наследоваание в традиционном ООП подраазумевает копирование
// при наследовании, в родительский класс копируются
// (некоторые методы перезаписываются), необходимые данные
// таким образом super - это указатель откуда копировать при нааследовании,
// но не такая ссылка, которая указывает откуда заимствовать (это скорее про JS)



// JS в то же время не подразумевает копирование
// в JS нет классов, есть объекты и эти объекты связываются
// друг с другом для получение данных

// фейковые способ "копирования" описанный выше ^
// Eksplicit mixin
function explicitMixin(sourceObj, targetObj) {
  for (var key in sourceObj) {
    if (!(key in targetObj)) {
      targetObj[key] = sourceObj[key];
    }
  }

  return targetObj;
}

var Vehicle = {
  engines: 1,

  ignition: function() {
    console.log('Turning on my engine');
  },

  drive: function() {
    this.ignition();
    console.log('Vehicle: driving right now');
  }
}

var Car = explicitMixin(Vehicle, {
  wheels: 4,

  drive: function() {

    // необходимо выполнить drive -> ignition() именно для Car
    // по этому используется explicit binding, чтобы
    // убедиться, что drive будет использовать контекст Car

    // explicit pseudopolymorphism
    Vehicle.drive.call(this);

    console.log('Car: driving right now');
  }
});

Car.drive()
