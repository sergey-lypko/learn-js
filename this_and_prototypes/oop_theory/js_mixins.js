// Eksplicit mixin
function explicitMixin(sourceObj, targetObj) {
  for (var key in sourceObj) {
    if (!(key in targetObj)) {
      
      // никакого копирования - ссылки на свойства и методы
      // просто передаются между объектами
      targetObj[key] = sourceObj[key];
    }
  }

  return targetObj;
}

var Vehicle = {
  engines: 1,

  ignition: function() {
    console.log('Turning on my engines', this.engines);
  },

  drive: function() {
    this.ignition();
  }
}

var SpeedBot = explicitMixin(Vehicle, {
  engines: 2,

  drive: function() {
    // JS вообще не предоставляет возможности к использованию relative polymorphism - 
    // язык не способен задавать поведение для полиморфных методов в теоретической цепочке наследования
    // которой в JS тоже нет, по той причине, что нет классов и нет традиционного наследования 
    // как такового вообще 
    // вместо этого все построено на ссылании и заимствовании методов между объектами

    // explicit pseudopolymorphism в JS:
    // так как оба объекта Vehicle и Car имеют метод с одинаковым именем - drive,
    // чтобы различить вызов на тот или иной, необходима абсолютная (не относительная) ссылка 
    // поэтому мы явно указывам имя объекта Vehicle и вызов метода от него
    
    // но если бы указали просто Vehicle.drive(), использовался бы контекст Vehicle
    // в связи с этим явное указание контекста - exsplicit binding
    Vehicle.drive.call(this);
    
    // таким образом метод drive переопределен, но сохраняет ссылку на родительский метод
    // с необходимым поведением - в данном случае это this.ignition();
    // в то же время можно отлично дополнить переопределенный метод любым другим поведением
    console.log('Making some another stuff here');
  }
});

SpeedBot.drive(); // Turning on my engines, 2

// в традиционных ОО-языках с относительным полиморфизмом, связь между 
// дочерним и родительским классами устанавливается единожды,
// в начале объявления класса - таким образом это будет единственное 
// место для управления/контроля поведения связанного с насл. и полиморф.

// но JS из-за своих особенностей, работает иначе:
// для каждой функции (метода), которая будет нуждаться в псевдополиморфизме
// вручную создается ссылка, что может очень сильно сказаться на потенциальном
// удобстве поддержки такого кода

// в то время как псевдополиморфизм может имитировать множественное наследование
// по факту это приведет только к большему усложнению и запутанности

// в итоге результатом такого кода является более сложный, трудноподдерживаемый 
// и плохо читабельный код
// СТОИТ ИЗБЕГАТЬ ИСПОЛЬЗОВАНИЯ ПСЕВДОПОЛИМОРФИЗМА когда возможно



// Implicit mixins
var Something = {
  name: 'Tony',
  
  sayHi: function() {
    console.log('Hey ho', this.name);
  }
}

var Another = {
  name: 'Mark',
  
  sayHi: function() {
    Something.sayHi.call(this);
  }
}

// как и говорилось выше, миксины не предпочтительны в языке JS в связи с тем,
// что несут в себе больше вреда (трудночитаемый и трудноподдеживаемый код) чем пользы
