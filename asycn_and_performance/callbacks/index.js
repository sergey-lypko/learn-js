// * . * . * . * . * . Sequential Brain . * . * . * . * . *
// * . * . * . * . * . * . * . * . * . * . * . * . * . * . *

// основная проблема callback функций в контексте async паттерна - это конфронтация с тем, как 
// рассуждает, мыслит и строит планы наш мозг: вся наша активность и планирование являются пошаговыми, 
// и в конкретный момент времени человек выполняет одну задачу
// В итоге вся мыслительная деятельность, 
// относительно планирования и формирования задач является пошаговой

// в то же время, асинхронные паттерны управления событиями вроде callback функций работают иначе: 
// вызовы откладываются, перемешиваются между собой в зависимости от результатовы выполнения, откладываются 
// по таймерам, а затем формируются в очередь
// именно из-за этого традиционная callback модель порой может
// накладывать некоторые трудности на понимание того или иного кода

// * . * . * . Nested/Chained Callbacks . * . * . *

doA(function() {
  doC()
  
  doD(function(){
    doF()
  })
  
  doE()
})

doB()

// данный всевдокод ^ именованно иллюстрирует порядок выполнения функций в цепи, но при условии
// того, что doA и doD будут являться асинхронными функциями 

// если же нет, порядок меняется.. A -> C -> D -> F -> E -> B
// выходит вложенность является проблемой? от части да, но это всего лишь побочный эффект

listen("click", handler);

function handler() {
  setTimeout(request, 500);
}

function request() {
  ajax("https://data.url", response);
}

function response(data) {
  // do stuff
}

// даже если записать асинхронный код, построенный на callback функциях без использования 
// вложенностей и отступов, не смотря на улучшенную читабельность, явно выделяются некотороые другие проблемы

// для того, чтобы последовательность вызовов была выполнена в определенном порядке, необходим 
// своего рода хардкод этого самого порядка, что в свою очередь делает код хрупким
// например если какой-то из этапов не будет достигнут, необходимо правильно обрабатывать ошибки, 
// а все это, с ростом кодовой базы становится все более мрачным
// кроме таго такой код становится повторяемым и труднодоступным для повторного использования

// даже когда есть четкий план, что как должно выполняться, указана обработка ошибок и исключений, 
// такой код становится все более запутанным и трудноподдерживаемым
// именно это и является основной проблеммой callback паттерна для асинхронных операций, 
// и именно из-за этого возникают такого рода ассоциации как callback hell, а вложенность, отступы 
// и читабельность всего лишь сторонний продукт такого кода

// callback ориентированный async паттерн выражает эту саммую асинхронность в крайне сложной для мозга 
// манере - нам необходимо прикладывать большие усилия, чтобы сихронизировать последовательности 
// вызовов, которые выполняются в коде с нашим восприятием 



// * . * . * . * . * . Trust issues . * . * . * . * . * . *
// * . * . * . * . * . * . * . * . * . * . * . * . * . * . *

// callback функции представляют собой потенциальную опасность так же в тех ситуациях, когда 
// предоставляются сторонними библиотеками или компонентами (в виде api, например)
// в таких ситуациях, порой крайне сложно полностью контроллировать их поведение, поскольку оно 
// производится из внешних модулей
// в таких ситуациях необходимо наворачивать много внешней логики для различных проверок и чеков (например, 
// чтобы callback функции не выполнялись более одного раза), 
// чтобы избежать потенциальных проблем в будущем, предоставить корректную обработку ошибок и 
// исключений, а так же многое другое

// некоторые api впрочем предоставляют разделение callback функций с учетом success и failure
function success(data) {
  console.log(data)
}

function failure(err) {
  console.log(err)
}

ajax("https://awesome.com", success, failure)

// или error-first style, как в ноде, например 
// где первый аргумент опционально представляет собой потенциальную ошибку 
function response(err, data) {
  if (err) {
    console.log(err)
    return 
  }
  
  console.log(data)
}

// следует отметить, что такие ^ подходы по-сути никак не решают проблемы, описанные выше
// либо даже хуже - в ситуациях, когда могут прийти и err и data, или например вызовутся обе функции для err и success
// таким образом остается необходимость в дополнительном коде для обработки всего этого 
// в то же время, такой код все так же не является переиспрльзуемым


// REVIEW
// ====================================================
// ====================================================
// непоследовательность и недостаток надежности  

// в то время как callback функции являются базовы элементом для построения асинхронного кода в JS, 
// они явно выполяют свою роль не лучшим образом

// во-первых, наш мозг склонен рассуждать иначе: линейно и последовательно, в то время как 
// функции обратного вызова - наоборот

// во-вторых и что более важно - это инверсия контроля 
// callback функции предоставляют возможность сторонним библиотеком, чей api используется в программе, 
// непосредственно вилять на эту самую программу и потенциально вести к серьезным багам

// некоторые api пытаются решить часть проблем с помощью ad hoc паттернов, вроде разделения функций при 
// success и failure, но это в свою очередь ведет к необходимости писать еще больше обработчиков и проверок каждый раз
