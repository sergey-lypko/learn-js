// * . * . * . * . * . Sequential Brain . * . * . * . * . *
// * . * . * . * . * . * . * . * . * . * . * . * . * . * . *

// основная проблема callback функций в контексте async паттерна - это конфронтация с тем, как 
// рассуждает, мыслит и строит планы наш мозг: вся наша активность и планирование являются пошаговыми, 
// и в конкретный момент времени человек выполняет одну задачу
// В итоге вся мыслительная деятельность, 
// относительно планирования и формирования задач является пошаговой

// в то же время, асинхронные паттерны управления событиями вроде callback функций работают иначе: 
// вызовы откладываются, перемешиваются между собой в зависимости от результатовы выполнения, откладываются 
// по таймерам, а затем формируются в очередь
// именно из-за этого традиционная callback модель порой может
// накладывать некоторые трудности на понимание того или иного кода

// * . * . * . Nested/Chained Callbacks . * . * . *

doA(function() {
  doC()
  
  doD(function(){
    doF()
  })
  
  doE()
})

doB()

// данный всевдокод ^ именованно иллюстрирует порядок выполнения функций в цепи, но при условии
// того, что doA и doD будут являться асинхронными функциями 

// если же нет, порядок меняется.. A -> C -> D -> F -> E -> B
// выходит вложенность является проблемой? от части да, но это всего лишь побочный эффект

