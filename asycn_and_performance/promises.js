// в общем с коллбеками ясно: неудобно и ненадежно, к тому же взрывает мозг
// но что если бы появилась возможность в программе просто обозначить, когда таск
// будет завершен, а затем наш собственный код решал, что делать дальше?


// * . * . * . Future value . * . * . *
// традиционный пример с покупкой бургера: 
// при заказе чизбургера на кассе создается своего рода обещание, что он (заказ) будет выполнен
// когда-то там в будущем, после чего можно будет заказ (значение) получить

// уже сейчас можно рассуждать о том, что с этим бургером можно будет сделать, полагаясь на future value
// такая теоретическая модель прекрасно вписывается в картину нашего мозга и после того, как заказ выполнен,
// происходит обмен value-promise на value itself

// в то же время возможен так же сценарий, когда бургер по каким-то причинам приготовить не удалось и в таком
// случае следует логический вывод:  future values могут предполагать собой как успех, так и неудачу выполнения
// каждый раз при заказе чизбургера, я точно знаю, что либо получу его, либо нет

// промисы позволяют работать с асинхронным кодом в синхронной манере
// они являются независимыми во времени и могут выстраиваться в композицию в предсказуемой манере

// * * Imutable value * *
// после того как промис успешно relosved, он становится иммутабельным значением и в дальнейшем
// это значение может быть неоднократно использовано
// это очень важный момент, поскольку такое значение становится безопасным для передачи в различные
// э-ты системы с гарантией того, что ни одна сторона не сможет изменить или повлиять на получаемое значение другой

// промисы являются прекрасно подходящим для повторения и повторного использования механизмом, 
// который позволяет инкапсулировать и выстроить в композиция будущие значения (future values)
