// Сам по себе движок языка не включает механизм, позволяющий асинхронно выполнять код.
// В определенный момент времени выполняется определенный фрагмент кода.
// Но какой именно фрагмент определяет EventLoop.

// Сoncurrency - это когда две или более цепочки событий чередуются с течением времени, 
// таким образом, такой процесс может представлять собой некое подобие одновременного выполнения
// (хотя всегда в конкретный момент времени выполняется только одно событие).

// Именно механизм EventLoop определяет как будут выполнятся различные фрагменты 
// кода с течением времени. EventLoop формируется для каждой вкладки браузера.

// Не смотря на то, что программа выполняется фрагмент за фрагментом, все они имеют общий 
// доступ к единому состоянию и области видимости программы.

// Например, при выполнении браузером Ajax-запроса,
// предполагаемые данные ответа сервера будут помещены в функцию обратного вызова (callback)
// (callback - call back into the program after something)
// и JS движок заявляет: "Эй, я собираюсь приостановить выполнение пока что, но когда этот запрос 
// будет выполнен и данные будут получены - эта функци должна быть вызывана обратно".
// Браузер ожидает ответа сервера и когда что-то есть, он помещает callback-функцию в EventLoop.

// EventLoop функционирует по принципу очереди (первый пришел - первый ушел)
// Концептуально это выглядт так:

var eventLoop = [];
var event;

while(true) {
  if (eventLoop.length > 0) {
    event = eventLoop.shift();
  }
  
  try {
    event();
  } catch (err) {
    reportError(err);
  }
}

// Каждая итерация такого ^ бесконечного цикла называется tick.
// Для каждого tick, если есть event который ожидает в очереди, 
// то он берется оттуда и выполняется. Эти events - функции обратного вызова.

// Нужно отметить, что setTimeout не помещает callback-функцию в EventLoop.
// Вместо этого, setTimeout устанавливает таймер, после завершения которого
// именно окружение (браузер, NodeJS и т.д) отправит callback-функцию в EventLoop,
// чтобы она затем выполнилась в одной из итераций tick, но только после всех остальных
// callback-функций, которые уже находятся в очереди. Это объясняет тот факт, что 
// setTimeout for n miliseconds не обязательно выполниться именно через n miliseconds. 

// Таким образом, программа разбивается на множество небольших фрагментов, 
// которые выполняются/происходят один за другим, следуя очереди EventLoop.

// Неплохая статья, связанная с EventLoop и не только:
// http://exploringjs.com/es6/ch_async.html


// * . * . * . Call stack  * . * . *

// Во время вызовов функций, где-то должна храниться информация о том, куда эти функции должны 
// вовращать свои значения и в каком порядке выполняться. 
// Такая информация управляется стэком вызовов функций - call stack.
// Это механизм, который обозначает местонахождение интерпритатора в конкретный момент времени.

// - когда скрипт вызывает функцию (например A), интерпритатор добавляет ее в call stack 
// - другие функции, которые вызываются из A, так же добавляются в call stack и вызываются соответственно
// - когда выполнение какой-либо функции завершено, интерпритатор убирает ее из стэка и 
//   продолжает дальнейшее выполнение из того места, где он остановился до начала выполнения
//   завершенной перед этим функции 
// - если очередь вызовов переполняется (потребляет больше памяти, чем выделено для этого) - 
//   возникает ошибка stack owerflow

// Каждый раз, когда выполняется функция, она добавляется в call stack. После выполнения всего ее кода, 
// функция удаляется оттуда. После выполнения всех функций call stack остается пуст.

function a() {
  console.log('a');
}

function b() {
  console.log('b1');
  
  a()
  
  // выполнение продолжится, только после того, как a() полностью выполнится
  console.log('b2');
}

b()

// output^: b1 -> a -> b2

// но при асинхронных операциях с callback функциями, дело, очевидно, обстоит иначе
function a() {
  console.log('a');
}

function b() {
  console.log('b1');
  
  setTimeout(() => {
    a()
  }, 0)
  
  console.log('b2');
}

b()

// output^: b1 -> b2 -> a



